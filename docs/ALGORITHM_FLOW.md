# 算法执行流程图

视频广告替换系统的核心算法执行顺序可视化。

---

## 🎬 完整执行流程

```
┌─────────────────────────────────────────────────────────────┐
│                   启动应用                                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【初始化】加载资源                                          │
│  • 加载 OpenCV.js                                           │
│  • 加载广告图片 → AdSource                                  │
│  • 加载视频                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【用户交互】标记 4 个角点                                   │
│  • 暂停到第一帧                                             │
│  • Canvas 点击事件 × 4                                      │
│  • 收集: [左上, 右上, 右下, 左下]                           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【算法 1】特征检测 - cv.goodFeaturesToTrack()              │
│                                                             │
│  输入:                                                      │
│    • 第一帧灰度图 (cv.cvtColor)                             │
│    • 4 个角点区域掩码                                       │
│  处理:                                                      │
│    • 计算 Shi-Tomasi 响应                                   │
│    • 选择最佳 100 个特征点                                  │
│  输出:                                                      │
│    • 100 个特征点坐标 [(x₁,y₁), ..., (x₁₀₀,y₁₀₀)]         │
│                                                             │
│  耗时: ~2ms                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
        ┌────────────────────────┐
        │   开始播放视频          │
        │   进入主循环            │
        └───────────┬────────────┘
                    │
                    ▼
╔═══════════════════════════════════════════════════════════════╗
║               主循环 - 每帧处理 (~40ms/帧)                    ║
╚═══════════════════════════════════════════════════════════════╝
                    │
     ┌──────────────┴──────────────┐
     │                             │
     ▼                             ▼
┌─────────────────┐      ┌─────────────────┐
│ 读取当前帧 RGBA │      │ 保存前一帧状态  │
│ 854×480×4       │      │ (供下次使用)    │
└────────┬────────┘      └─────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│  【算法 2】颜色空间转换 - cv.cvtColor()                      │
│                                                             │
│  输入: 当前帧 RGBA (854×480×4)                              │
│  参数: cv.COLOR_RGBA2GRAY                                   │
│  输出: 灰度图 (854×480×1)                                   │
│                                                             │
│  耗时: ~1ms                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【算法 3】光流跟踪 - cv.calcOpticalFlowPyrLK()              │
│                                                             │
│  输入:                                                      │
│    • prevGray: 前一帧灰度图                                 │
│    • currentGray: 当前帧灰度图                              │
│    • prevFeatures: 100 个旧特征点                           │
│  参数:                                                      │
│    • winSize: 21×21 (搜索窗口)                              │
│    • maxLevel: 3 (金字塔层数)                               │
│    • criteria: 30 次迭代或 ε<0.01                           │
│  处理:                                                      │
│    ├─ Level 2: 缩放到 1/4 分辨率，粗略估计                  │
│    ├─ Level 1: 缩放到 1/2 分辨率，精细调整                  │
│    └─ Level 0: 原始分辨率，最终优化                         │
│  输出:                                                      │
│    • nextFeatures: 100 个新特征点位置                       │
│    • status: [1,0,1,...] 跟踪状态                          │
│    • err: 误差值                                            │
│                                                             │
│  耗时: ~15ms ⚠️ 性能瓶颈                                    │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【算法 4】角点更新 - 平均偏移法 (自定义)                    │
│                                                             │
│  输入:                                                      │
│    • prevFeatures, nextFeatures, status                    │
│    • 旧角点 [C₁, C₂, C₃, C₄]                                │
│  计算:                                                      │
│    Step 1: 计算平均偏移                                     │
│      for i in 成功跟踪的点:                                 │
│        dx[i] = nextFeatures[i].x - prevFeatures[i].x       │
│        dy[i] = nextFeatures[i].y - prevFeatures[i].y       │
│      avgDx = Σdx / count                                    │
│      avgDy = Σdy / count                                    │
│                                                             │
│    Step 2: 应用到角点                                       │
│      newCorner[j] = oldCorner[j] + (avgDx, avgDy)          │
│                                                             │
│    Step 3: 3帧移动平均平滑                                  │
│      history.push(newCorner)                                │
│      if history.length > 3: history.shift()                 │
│      smoothedCorner = avg(history)                          │
│                                                             │
│  输出: 平滑后的 4 个角点                                     │
│                                                             │
│  耗时: <1ms                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【算法 5.1】计算透视矩阵 - cv.getPerspectiveTransform()     │
│                                                             │
│  输入:                                                      │
│    • srcPoints: 广告图片 4 角 [(0,0), (w,0), (w,h), (0,h)] │
│    • dstPoints: 视频中跟踪的 4 角                           │
│  计算:                                                      │
│    求解 3×3 单应性矩阵 H:                                   │
│    [x']   [h₁₁ h₁₂ h₁₃] [x]                                │
│    [y'] = [h₂₁ h₂₂ h₂₃] [y]                                │
│    [w']   [h₃₁ h₃₂ 1  ] [1]                                │
│                                                             │
│    x_final = x'/w', y_final = y'/w'                         │
│                                                             │
│  输出: 3×3 变换矩阵 H                                        │
│                                                             │
│  耗时: <1ms                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  【算法 5.2】应用透视变换 - cv.warpPerspective()             │
│                                                             │
│  输入:                                                      │
│    • adMat: 广告图像 RGBA                                   │
│    • H: 透视变换矩阵                                        │
│    • dsize: 输出尺寸 854×480                                │
│  处理:                                                      │
│    for 输出图像每个像素 (x', y'):                           │
│      1. 逆变换: (x, y) = H⁻¹ * (x', y')                    │
│      2. 双线性插值获取颜色                                  │
│      3. 如果超出源图像范围 → 透明 (0,0,0,0)                 │
│  输出:                                                      │
│    • warpedAd: 变形后的广告 (854×480×4)                    │
│                                                             │
│  耗时: ~5ms                                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
              ┌──────┴──────┐
              │ 启用前景检测? │
              └──────┬──────┘
                     │
        ┌────────────┴────────────┐
        │ YES                     │ NO
        ▼                         ▼
╔═══════════════════════╗   ┌─────────────────┐
║  前景检测分支          ║   │  简单渲染分支    │
╚═══════════════════════╝   └─────────────────┘
        │                         │
        ▼                         │
┌────────────────────────────────────────┐
│ 【算法 6.1】颜色转换                    │
│   cv.cvtColor(prevFrame, RGBA2GRAY)   │
│   cv.cvtColor(currentFrame, RGBA2GRAY)│
│                                        │
│ 耗时: ~2ms                             │
└───────────────┬────────────────────────┘
                │
                ▼
┌────────────────────────────────────────┐
│ 【算法 6.2】帧差法 - cv.absdiff()       │
│                                        │
│ 输入: prevGray, currentGray            │
│ 计算: diff = |current - prev|         │
│ 输出: 差异图像 diff                    │
│                                        │
│ 耗时: ~1ms                             │
└───────────────┬────────────────────────┘
                │
                ▼
┌────────────────────────────────────────┐
│ 【算法 6.3】二值化 - cv.threshold()     │
│                                        │
│ 输入: diff 差异图像                    │
│ 参数: thresh=25, type=BINARY           │
│ 计算: mask = (diff > 25) ? 255 : 0    │
│ 输出: 二值遮罩 (255=运动, 0=静止)      │
│                                        │
│ 耗时: ~1ms                             │
└───────────────┬────────────────────────┘
                │
                ▼
┌────────────────────────────────────────┐
│ 【算法 6.4】形态学膨胀 - cv.dilate()    │
│                                        │
│ 输入: mask 二值遮罩                    │
│ 参数: kernel=椭圆(5×5)                 │
│ 计算: 扩大白色区域，填补孔洞           │
│ 输出: 膨胀后的 mask                    │
│                                        │
│ 耗时: ~3ms                             │
└───────────────┬────────────────────────┘
                │
                ▼
┌────────────────────────────────────────┐
│ 【算法 6.5】高斯模糊 - cv.GaussianBlur()│
│                                        │
│ 输入: mask                             │
│ 参数: ksize=5×5, sigma=auto           │
│ 计算: 平滑边缘                         │
│ 输出: 模糊后的 mask                    │
│                                        │
│ 耗时: ~3ms                             │
└───────────────┬────────────────────────┘
                │
                ▼
┌────────────────────────────────────────┐
│ 【算法 7】遮罩 Alpha 混合 (手动实现)    │
│                                        │
│ for 每个像素 (i, j):                   │
│   adAlpha = warpedAd[i,j].a / 255     │
│   maskValue = mask[i,j] / 255         │
│   bgConf = 1.0 - maskValue  # 背景置信度│
│                                        │
│   if adAlpha > 0.1 && bgConf > 0.5:   │
│     finalAlpha = adAlpha * bgConf     │
│     for c in [R,G,B]:                 │
│       result[i,j][c] =                │
│         video[i,j][c] * (1-finalAlpha)│
│         + ad[i,j][c] * finalAlpha     │
│                                        │
│ 耗时: ~10ms                            │
└───────────────┬────────────────────────┘
                │
                │         简单渲染分支
                │              │
                │              ▼
                │   ┌────────────────────────┐
                │   │【算法 7】简单 Alpha 混合 │
                │   │                        │
                │   │ for 每个像素:           │
                │   │   alpha = ad[i,j].a    │
                │   │   if alpha > 0.1:      │
                │   │     result = video * (1-α)│
                │   │            + ad * α    │
                │   │                        │
                │   │ 耗时: ~10ms            │
                │   └────────┬───────────────┘
                │            │
                └────────────┴──────────┐
                                        │
                                        ▼
                        ┌───────────────────────────┐
                        │ 显示到 Canvas              │
                        │ cv.imshow(canvas, result) │
                        └──────────┬────────────────┘
                                   │
                                   ▼
                        ┌───────────────────────┐
                        │ 清理临时 Mat 对象      │
                        │ result.delete()       │
                        │ currentFrame.delete() │
                        │ warpedAd?.delete()    │
                        └──────────┬────────────┘
                                   │
                                   ▼
                        ┌───────────────────────┐
                        │ requestAnimationFrame │
                        │ 继续下一帧             │
                        └──────────┬────────────┘
                                   │
                                   │
                    ┌──────────────┴──────────────┐
                    │                             │
                    ▼                             ▼
            视频未结束/未暂停               视频结束/暂停
                    │                             │
                    └────► 返回主循环              └──► 停止处理
```

---

## 📊 算法依赖关系图

```
初始化阶段:
┌───────────────┐
│ 用户标记 4 点  │
└───────┬───────┘
        │
        ▼
┌──────────────────┐
│ 特征检测          │
│ goodFeaturesToTrack│
└──────────────────┘

每帧处理阶段:
┌──────────────┐
│ 读取当前帧    │
└──────┬───────┘
       │
       ├────────────────────────────────────┐
       │                                    │
       ▼                                    ▼
┌──────────────┐                    ┌──────────────┐
│ cvtColor     │                    │ (前一帧缓存) │
│ RGBA→Gray    │                    └──────────────┘
└──────┬───────┘
       │
       ├──────────────────┐
       │                  │
       ▼                  ▼
┌──────────────┐   ┌─────────────────┐
│ 光流跟踪      │   │ 前景检测         │
│ calcOptical   │   │ (可选)          │
│ FlowPyrLK    │   │                 │
└──────┬───────┘   │ • absdiff       │
       │           │ • threshold     │
       ▼           │ • dilate        │
┌──────────────┐   │ • GaussianBlur  │
│ 角点更新      │   └────────┬────────┘
│ (平均偏移)    │            │
└──────┬───────┘            │
       │                    │
       ▼                    │
┌──────────────────┐        │
│ 透视变换          │        │
│ • getPerspective │        │
│ • warpPerspective│        │
└──────┬───────────┘        │
       │                    │
       └────────┬───────────┘
                │
                ▼
        ┌──────────────┐
        │ Alpha 混合    │
        │ (像素级循环)  │
        └──────┬───────┘
               │
               ▼
        ┌──────────────┐
        │ 显示到 Canvas │
        └──────────────┘
```

---

## ⏱️ 性能时序图

```
每帧 40ms 时间分配:

0ms  ├──────────────────────────────────────────────┤ 40ms
     │                                              │
     │ 读取帧 & 颜色转换                            │
     ├─┤ 1ms                                        │
     │                                              │
     │ 光流跟踪 ████████████████                    │
     ├──────────────────┤ 15ms (37.5%)             │
     │                                              │
     │ 角点更新 ▌                                   │
     ├┤ <1ms                                        │
     │                                              │
     │ 透视变换 ██████                              │
     ├──────┤ 5ms                                   │
     │                                              │
     │ 前景检测 ████                                │
     ├────┤ 3ms (阈值+膨胀)                         │
     ├────┤ 3ms (模糊)                              │
     │                                              │
     │ Alpha 混合 ███████████                       │
     ├───────────────┤ 10ms (25%)                   │
     │                                              │
     │ 显示 & 清理 ▌                                │
     ├┤ <1ms                                        │
     │                                              │
     │ [剩余缓冲] ██                                │
     └──────────────────────────────────────────────┘

瓶颈:
🔴 光流跟踪: 15ms (37.5%)
🟡 Alpha 混合: 10ms (25%)
🟢 其他: 15ms (37.5%)
```

---

## 🔀 算法分支决策树

```
                    开始处理帧
                        │
                        ▼
            ┌───────────────────────┐
            │ 跟踪状态 == 'active'? │
            └───────┬───────────────┘
                    │
        ┌───────────┴───────────┐
        NO                      YES
        │                       │
        ▼                       ▼
    返回旧角点          执行光流跟踪
        │                       │
        │                       ▼
        │           ┌───────────────────┐
        │           │ 成功率 >= 50%?    │
        │           └───────┬───────────┘
        │                   │
        │       ┌───────────┴───────────┐
        │       YES                     NO
        │       │                       │
        │       ▼                       ▼
        │   重置丢失计数         丢失计数++
        │       │                       │
        │       │                       ▼
        │       │           ┌───────────────────┐
        │       │           │ 丢失计数 > 5?     │
        │       │           └───────┬───────────┘
        │       │                   │
        │       │       ┌───────────┴───────────┐
        │       │       YES                     NO
        │       │       │                       │
        │       │       ▼                       │
        │       │   标记为 'lost'                │
        │       │   触发回调                     │
        │       │       │                       │
        │       └───────┴───────────────────────┘
        │                   │
        └───────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │ 更新角点坐标           │
        └───────┬───────────────┘
                │
                ▼
        ┌───────────────────────┐
        │ 角点在边界内?          │
        └───────┬───────────────┘
                │
        ┌───────┴───────┐
        YES             NO
        │               │
        ▼               ▼
    执行透视变换    跳过变换
        │           (warpedAd=null)
        │               │
        └───────┬───────┘
                │
                ▼
        ┌───────────────────────┐
        │ 启用前景检测?          │
        └───────┬───────────────┘
                │
        ┌───────┴───────┐
        YES             NO
        │               │
        ▼               ▼
    遮罩渲染         简单渲染
        │               │
        └───────┬───────┘
                │
                ▼
            显示结果
```

---

## 📝 伪代码总览

```python
# ========== 初始化阶段 ==========
def initialize(corners, firstFrame):
    gray = cvtColor(firstFrame, GRAY)
    mask = createMask(corners, radius=30)
    features = goodFeaturesToTrack(gray, mask, maxCorners=100)
    return features, gray

# ========== 主循环 ==========
def processFrame(currentFrame):
    # 1. 颜色转换
    currentGray = cvtColor(currentFrame, GRAY)

    # 2. 光流跟踪
    nextFeatures, status = calcOpticalFlowPyrLK(
        prevGray, currentGray,
        prevFeatures,
        winSize=21, maxLevel=3
    )

    # 3. 检查跟踪质量
    successRate = count(status == 1) / len(status)
    if successRate < 0.5:
        lostFrameCount++
        if lostFrameCount > 5:
            trackingStatus = 'lost'
            onTrackingLost()

    # 4. 更新角点
    avgDx, avgDy = calcAverageDisplacement(prevFeatures, nextFeatures, status)
    newCorners = oldCorners + (avgDx, avgDy)
    smoothedCorners = movingAverage(newCorners, windowSize=3)

    # 5. 透视变换
    if isInBounds(smoothedCorners):
        H = getPerspectiveTransform(adCorners, smoothedCorners)
        warpedAd = warpPerspective(adImage, H, videoSize)
    else:
        warpedAd = null

    # 6. 前景检测（可选）
    if enableForegroundDetection:
        diff = absdiff(currentGray, prevGray)
        mask = threshold(diff, thresh=25)
        mask = dilate(mask, kernel=5)
        mask = GaussianBlur(mask, ksize=5)

    # 7. 渲染
    result = currentFrame.clone()
    if warpedAd is not null:
        if enableForegroundDetection:
            result = blendWithMask(result, warpedAd, mask)
        else:
            result = simpleBlend(result, warpedAd)

    # 8. 显示
    imshow(canvas, result)

    # 9. 更新状态
    prevGray = currentGray
    prevFeatures = nextFeatures

    # 10. 清理
    delete(result, currentGray, warpedAd)

    # 11. 下一帧
    requestAnimationFrame(processFrame)

# ========== 辅助函数 ==========
def blendWithMask(video, ad, mask):
    for i, j in pixels:
        adAlpha = ad[i,j].alpha / 255
        maskValue = mask[i,j] / 255
        bgConfidence = 1 - maskValue

        if adAlpha > 0.1 and bgConfidence > 0.5:
            finalAlpha = adAlpha * bgConfidence
            video[i,j] = video[i,j] * (1 - finalAlpha) + ad[i,j] * finalAlpha

    return video
```

---

**文档版本**: v1.0.0
**最后更新**: 2026-01-02
